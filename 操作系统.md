# 操作系统
学习视频链接：https://www.bilibili.com/video/av6538245?from=search&seid=5236185601313183172  

### 操作系统的启动（不好意思，没看）
### 中断和异常
中断的引入是为了



### 地址空间



### 进程与线程
进程的定义：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程

##### 进程的组成
1. 程序的代码
2. 程序处理的数据
3. 程序计数器中的值，指示吓一跳将运行的指令
4. 一组通用的寄存器的当前值，堆、栈
5. 一组系统资源（如打开的文件）

##### 进程与程序的联系于区别
联系：  
1. 程序是产生进程的基础
2. 程序的每次运行构成不同的进程
3. 进程是程序功能的体现

区别：  
1. 进程是动态的，程序是静态的，进程有核心态和用户态
2. 进程是暂时的，程序是永久的
3. 进程和程序组成不同：进程的组成包括程序、数据和进程控制块（即进程状态信息）

##### 进程的特点
1. 动态性
2. 并发性  
> 并发：1个CPU手上有多个任务都在执行中，但每个时刻只能执行一个任务，其它任务在等待  
> 并行：多个CPU同时执行  
3. 独立性:不同进程的工作不相互影响；（依据页表来保证，每个进程分配在不同的页表）
4. 制约性：因访问共享数据/资源或进程间同步而产生的

##### 描述进程的数据结构：进程控制块（Process Control Block, PCB）
操作系统为每个进程维护一个PCB，用来存储进程的状态信息

PCB含有三大类信息：  
1. 进程标识信息：产生者者标识、用户标识
2. 进程的状态信息：寄存器
3. 进程的控制信息：调度和状态信息等

##### 进程状态（创建状态、运行状态、等待状态、就绪状态、结束状态）
![image](https://github.com/allmissing/Large-Data/blob/master/%E8%BF%9B%E7%A8%8B5%E7%8A%B6%E6%80%81.png)
1. 进程的生命周期管理：创建->运行->等待（阻塞）->唤醒（只能被其它进程或操作系统唤醒）->结束（正常退出、错误退出、致命错误、被其它进程杀死）
2. 进程的状态变化模型
3. 进程的挂起模型
进程挂起：把一个进程从内存转到外存  
挂起状态：①阻塞挂起状态：进程在外存并等待某时间的出现 ②就绪挂起状态：进程在外存，但只能进入内存，即可运行  
阻塞到阻塞挂起  
就绪到阻塞挂起  
运行到就绪挂起  
阻塞挂起到就绪挂起（在外存）  
解挂:阻塞挂起到阻塞、就绪挂起到就绪  

状态队列：就绪进程有一个队列存放所有就绪进程、阻塞进程有一个队列存放阻塞进程

##### 线程
1. 为什么引入线程？  
为了效率使用多进程时存在两个问题，不同进程使用不同的地址空间，程序执行的结果在进程之间的传递是一个问题，第二个问题是进程之间的切换需要进行状态的转换，时间消耗比较大。为此需要一个泵狗实现并发并且使用相同地址空间的实体，因此引入线程。     
2. 线程与进程最大的区别在于：线程之间可以使用相同的地址空间   
3. 进程与线程的关系：进程主要用于管理资源，程序执行交给线程，所以进程=资源管理+线程  
4. TCB（线程控制块）
5. 线程的优点：
> 一个进程中可以同时存在多个线程  
> 各个线程之间可以并发执行  
> 各个线程之间可以共享地址空间和文件等资源  
6. 线程的缺点：一个线程的执行错误可能会造成所有线程的执行错误（因为共享资源）
7. 线程与进程的比较  
> 进程是资源分配单位，线程是CPU调度单位；  
> 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；  
> 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；  
> 线程能减少并发执行的时间和空间开销：  
>> 线程的创建时间比进程短  
>> 线程的终止时间比进程短  
>> 同一进程内的线程切换时间比进程短（进程处在不同页表，线程在相同页表，不用切换）  
>> 由于同一进程的各个线程间共享内存和文件资源，可直接进行不通过内核的通信  

8. 线程的实现  
> a. 用户线程（操作系统看不到的线程，由用户线程库管理）：在用户空间实现（POSIX Pthreads, Mach C-threads,Solaris threads）  
> 用户线程缺点:
>> 如果一个线程发起系统调用而阻塞，则整个进程在等待  
>> 当一个线程开始运行后，除非它主动交出CPU的使用权，否则所在的进程当中的其它线程将无法
>> 由于时间片分配给进程，故与其它进程比，在多线程执行时，每个线程得到的时间片极少，执行会较慢  

> b. 内核线程（由操作系统管理的线程）：在内核中实现（Windows,Solaris,Linux）
>> 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息（PCB和TCB）  
>> 线程的创建、终止和切换都是通过系统调用/内核函数的方式来进行，由内核来完成，因此系统开销极大  
>> 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的执行  
>> 时间片分配给线程，多线程的进程获得更多CPU时间  

> c. 轻量级线程：在内核中实现，支持用户线程（Solaris）

9. 用户线程和内核线程的对应关系：多对一、一对一、多对多  

10. 上下文切换：进程之间的切换，切换不同进程的寄存器信息，这些信息成为上下文

11. 线程的创建：在Unix系统中，用fork()复制线程，再用exec()来执行线程  
具体过程参见：https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/courseware/59abbfc019ef4006924c986c99f8b26b/eee38a4abfc947f787be9cdecc7357ab/  



